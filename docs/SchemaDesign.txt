üß† Design Decisions and Rationale
1Ô∏è‚É£ Normalization

The JSON source mixed unrelated attributes into one object.
We applied 3rd Normal Form (3NF) to separate logical entities:
property holds static attributes (address, structure).
Other tables store variable or repeating data (valuation, rehab, etc.).
This improves data integrity, reduces redundancy, and supports incremental updates.

2Ô∏è‚É£ Primary & Foreign Keys

Each table uses a surrogate key (*_id) as primary key for internal joins.
property_id acts as the referential key across all child tables.
This maintains referential integrity and simplifies one-to-many relationships.

3Ô∏è‚É£ Referential Integrity

Every child table (leads, valuation, hoa, rehab, taxes) references property(property_id) via a foreign key constraint.
ON DELETE CASCADE can be optionally enabled if we want automatic cleanup when a property is deleted.

4Ô∏è‚É£ 1:1 vs 1:N Constraints

For 1:1 relationships (taxes), a UNIQUE constraint was added on property_id.
For 1:N relationships, no uniqueness constraint allows multiple dependent records.

5Ô∏è‚É£ Data Cleaning Decisions

Nulls, blank strings, and placeholders like "null" or " " were standardized to NULL.
Inconsistent yes/no values (y, N, true) were normalized to "Yes" / "No".
Extreme numeric outliers (e.g., negative tax or >10M valuation) were capped or set to NULL.
Empty ‚ÄúMarket‚Äù values were labeled "Unknown" for clarity.

6Ô∏è‚É£ ETL Flow

Extract: Load raw JSON using pandas.read_json().
Transform: Normalize nested structures (Valuation, Rehab, HOA) into separate DataFrames.
Clean: Apply consistent cleaning functions (clean_text, yes_no_normalize, etc.).
Load: Use SQLAlchemy + pandas.to_sql() to insert into normalized tables in correct order.

7Ô∏è‚É£ Performance & Scalability

Bulk inserts via pandas.to_sql() ensure fast loading for large datasets.
Indexes on property_id in all child tables improve join and lookup performance.
Modular cleaning functions allow easy extension to future data sources.

‚úÖ Outcome

The final schema is relational, consistent, and query-efficient.

It supports both analytical queries (e.g., valuation trends, yield analysis)
and business monitoring (e.g., property status by market, rehab cost summary).

The design aligns with Data Engineering best practices ‚Äî
separating static (dimension-like) data from dynamic (fact-like) data.

üß≠ Example Query: End-to-End Relationship

To fetch a full property overview:

SELECT 
    p.Property_Title,
    p.City, p.State, 
    v.List_Price, v.Redfin_Value,
    r.Rehab_Calculation,
    l.Most_Recent_Status,
    t.Taxes
FROM property p
LEFT JOIN valuation v ON p.property_id = v.property_id
LEFT JOIN rehab r ON p.property_id = r.property_id
LEFT JOIN leads l ON p.property_id = l.property_id
LEFT JOIN taxes t ON p.property_id = t.property_id
WHERE p.Market = 'Chicago';